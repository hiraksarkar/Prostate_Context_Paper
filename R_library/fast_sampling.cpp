#include <Rcpp.h>
#include <RcppEigen.h>
// [[Rcpp::depends(dqrng, BH, sitmo, RcppEigen)]]
#include <xoshiro.h>
#include <dqrng_distribution.h>
// [[Rcpp::plugins(cpp11)]]
// [[Rcpp::plugins(openmp)]]
#include <omp.h>
#include <iostream>

typedef double countType;
typedef Eigen::SparseVector<countType> spV;

// sample_mixtures(): sample molecules for beads given template expression profiles, a profile-cell mixing matrix, and bead sizes
// profiles - sparse normalized count matrix, where each column is an expression profile (each row is a gene). Importantly, the matrix has to be column-normalized: the sum of values in each column must be equal to 1.0
// beadMixtures - a sparse matrix, specifying for each bead (columns), what proportion of molecules should be sampled from each profile (rows)
// beadSizes - a vector specifying for each bead, how many molecules should be sampled in total
// seed - random number generator seed
// return: gene by bead sparse count matrix
// [[Rcpp::export]]
Eigen::SparseMatrix<countType> sample_mixtures(const Eigen::SparseMatrix<double> &profiles, const Eigen::SparseMatrix<double> &beadMixtures, const std::vector<int> beadSizes, int ncores, int seed=42) {

  // set up random number generation
  dqrng::uniform_distribution dist(0.0, 1.0); // Uniform distribution [0,1)
  dqrng::xoshiro256plus rng(seed);              // properly seeded rng

  int nbeads=beadSizes.size();
  int ngenes=profiles.rows();
  std::vector<spV> molecules(nbeads); // will accumulate sampled molecules here

#pragma omp parallel num_threads(ncores)
  {
    dqrng::xoshiro256plus lrng(rng);      // make thread local copy of rng 
    lrng.long_jump(omp_get_thread_num() + 1);  // advance rng by 1 ... ncores jumps

    std::vector<spV> molecules_private; // will accumulate sampled molecules here
    std::vector<int> beadIds_private; 
    // nowait?
#pragma omp for 
    for (int i = 0; i < nbeads; i++) { // for each bead
      // a temp vector to add up molecules from different parts of the mixture
      Eigen::VectorXi v= Eigen::VectorXi::Constant(ngenes,0.0);
      int beadSize=beadSizes[i];
      
      // for each mixing element of the bead
      for(Eigen::SparseMatrix<double>::InnerIterator it(beadMixtures,i); it; ++it) {
	int nmols=round(it.value()*beadSize);
	//std::cout<<i<<": taking "<<nmols<<" from cell "<<it.index()<<std::endl;
	
	std::vector<double> rns(nmols); // random numbers which will define what genes each molecule is sampled from
	for (int j = 0; j < nmols; j++) {
	  rns[j] = dist(lrng);
	}
	std::sort(rns.begin(),rns.end());

	// now we go through the randomly sampled numbers and gene fractions at the same time, incrementing counts for genes as needed

	double pfs=0.0; // profile fraction seen - determines what fraction of profile molecules we've already seen - this determines whether we need to advance to a next gene to keep up with the random rns values; 0 means that we haven't seen any profile molecules yet
	Eigen::SparseMatrix<double>::InnerIterator pi(profiles,it.index()); // profile iterator
	int gene=0;
	pfs+=pi.value(); // increment molecule fraction to signify that we starting at a first gene

	for(double p : rns) { // iterate over sampled sorted probabilities
	  while(pfs<p && pi) { 
	    ++pi; // advance to the next gene
	    if(pi) { pfs+=pi.value(); gene=pi.index(); }
	  }
	  v(gene)+=1; // add a molecule of a gene
	}
      }
      
      // translate v into triplets ... might as well do this manually
      molecules_private.push_back(v.sparseView());
      beadIds_private.push_back(i);
    }

    // merge the molecules generated by this thread into the combined vector
#pragma omp critical
    for(int i=0;i<beadIds_private.size();i++) {
      molecules[beadIds_private[i]]=molecules_private[i];
    }
  }
  
  // create sparse matrix out of a beads SparseVector list (note: all this to do do.call(cbind,beads) ... Eigen doesn't appear to provide any help here
  
  // calculate the number of non-zero values, recording column starts (outerIndex in Eigen speak)
  int tnnz=0;
  std::vector<int> outerIndexPtr(molecules.size()+1);
  outerIndexPtr[0]=0;
  for(auto i=molecules.begin(); i!=molecules.end(); ++i) {
    tnnz+= i->nonZeros();
    outerIndexPtr[i-molecules.begin()+1]=tnnz;
  }

  
  // concatenate the SparseVector index/values
  std::vector<double> values(tnnz);
  std::vector<int> innerIndices(tnnz);

  int k=0, l=0;
  for(auto i=molecules.begin(); i!=molecules.end(); ++i) {
    for(spV::InnerIterator j(*i); j; ++j,++k) {
	innerIndices[k]=j.index();
	values[k]=j.value();
    }
  }
  
  // construct return object
  Eigen::Map<Eigen::SparseMatrix<double> > res(ngenes,molecules.size(),tnnz,outerIndexPtr.data(), innerIndices.data(),values.data());
  return res;
}
